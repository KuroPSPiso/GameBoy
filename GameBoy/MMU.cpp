#include "MMU.h"


void MMU::Set_Bios()
{
	_IsInBios = true;
	_BIOS = (new uint8[0x0100]{
	//	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 
		0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E, //0
		0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0, //1
		0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B, //2
		0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9, //3
		0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20, //4
		0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04, //5
		0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2, //6
		0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06, //7
		0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20, //8
		0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17, //9
		0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, //a
		0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E, //b
		0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC, //c
		0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C, //d
		0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20, //e
		0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50	//f
	});
}

void MMU::BIOSLoaded(BOOL value)
{
	_IsInBios = (value == TRUE)? FALSE : TRUE;
	
	for (int i = 0x00; i < 0x2000; i++)
	{
		_VRAM[i] = 0x00;
	}
}

MMU::MMU(Cartidge* cartridge)
{
	_cartridge = cartridge;
	MMU::Reset();
}


MMU::~MMU()
{
	delete[] _BIOS;
	delete[] _ROM;
	delete[] _VRAM;
	delete[] _ERAM;
	delete[] _WRAM;
	delete[] _OAM;
	delete[] _IO;
	delete[] _ZPRAM;
	delete _cartridge;
}

void MMU::Reset()
{
	Set_Bios();
	_ROM = _cartridge->Get_ROM(); //bottom 32k
	_VRAM = new uint8[0x2000];
	_ERAM = new uint8[0x2000];
	_WRAM = new uint8[0x2000]; // duplicates from 0xC000-0xDE00 to 0xE000-FDFF
	_OAM = new uint8[0x00A0];
	_IO = new uint8[0x004C];
	_ZPRAM = new uint8[0x0079];
	_input = new Input();

	for (uint16 address = 0x8000; address < 0xFFFF; address += 0x01)
	{
		//clear all data
		Write8(address, 0x00);
	}
}

uint8 MMU::Read8(uint16 address)
{
	uint8 result = 0;

	if (address >= 0xE000 && address < 0xFE00)
	{
		address -= 0x2000;
	}

	switch (address & 0xF000)
	{
	case 0xF000:
		if (address == 0xFFFF)
		{
			result = _IFlag;
		}
		else if (address >= 0xFF80)
		{
			result = _ZPRAM[address - 0xFF80];
		}
		else if (address < 0xFF4C && address >= 0xFF00)
		{
			result = _IO[address - 0xFF00];
			if (address == P1)
			{
				result = _input->Read8();
			}
		}
		else if (address < 0xFEA0 && address >= 0xFE00)
		{
			result = _OAM[address - 0xFE00];
		}
		break;
	case 0xD000:
	case 0xC000:
		result = _WRAM[address - 0xC000];
		break;
	case 0xB000:
	case 0xA000:
		result = _ERAM[address - 0xA000];
		break;
	case 0x9000:
	case 0x8000:
		result = _VRAM[address - 0x8000];
		break;
	case 0x7000:
	case 0x6000:
	case 0x5000:
	case 0x4000:
	case 0x3000:
	case 0x2000:
	case 0x1000:
	case 0x0000:
		if (_IsInBios) 
		{ 
			if (address < 0x100) result = _BIOS[address];
			else
			{
				result = _ROM[address];
			}
		}
		else { result = _ROM[address]; }
		break;
	}

	return result;
}

uint16 MMU::Read16(uint16 address)
{
	return Read8(address) + (Read8(address + 1) << 8);
}

void MMU::Write8(uint16 address, uint8 value)
{

	if (address >= 0xE000 && address < 0xFE00)
	{
		address -= 0x2000;
	}

	switch (address & 0xF000)
	{
	case 0xF000:
		if (address == 0xFFFF)
		{
			_IFlag = value;
		}
		else if (address >= 0xFF80)
		{
			_ZPRAM[address - 0xFF80] = value;
		}
		else if (address < 0xFF4C && address >= 0xFF00)
		{
			_IO[address - 0xFF00] = value;

			if (address == P1)
			{
				_input->Write8(value);
			}
			else if (address == ROMSTAT)
			{
				BIOSLoaded((value == 0x01) ? TRUE : FALSE);
			}
			else if (address == DMA)
			{
				_IO[DMA - 0xFF00] = value;
				DMATransfer();
			}
		}
		else if (address < 0xFEA0 && address >= 0xFE00)
		{
			_OAM[address - 0xFE00] = value;
		}
		break;
	case 0xD000:
	case 0xC000:
		_WRAM[address - 0xC000] = value;
		break;
	case 0xB000:
	case 0xA000:
		_ERAM[address - 0xA000] = value;
		break;
	case 0x9000:
	case 0x8000:
	{
		_VRAM[address - 0x8000] = value;

		////update tile
		//uint16 base = address & 0x1FFE;
		//uint16 tile = (base >> 4) & 0x1FF;
		//uint16 y = (base >> 1) & 0x07;

		//uint16 sx;
		//for (uint8 x = 0; x < 0x08; x++)
		//{
		//	sx = 1 << (7 - x);
		//	_VRAM[(tile + y + x)] = ((_VRAM[address - 0x8000] & sx) ? 1 : 0) + ((_VRAM[address - 0x7FFF] & sx) ? 2 : 0);
		//}
	}
		break;
	case 0x7000:
	case 0x6000:
	case 0x5000:
	case 0x4000:
	case 0x3000:
	case 0x2000:
	case 0x1000:
	case 0x0000:
		_ROM[address] = value;
		break;
	}
}

void MMU::Write16(uint16 address, uint16 value)
{
	Write8(address,				value & 0x00FF);
	Write8(address + 0x0001,	value >> 8);
}

Input* MMU::ReadInput()
{
	return _input;
}

void MMU::WriteInput(BOOL isDirectional)
{
	uint8 input = 0x00;
	uint8 registeredInput = _input->GetController();
	if (isDirectional)
	{
		Set_Bit(input, 0, Get_Bit(registeredInput, 0));
		Set_Bit(input, 1, Get_Bit(registeredInput, 1));
		Set_Bit(input, 2, Get_Bit(registeredInput, 2));
		Set_Bit(input, 3, Get_Bit(registeredInput, 3));
		_input->Write8(0x10);
	}
	else
	{
		Set_Bit(input, 0, Get_Bit(registeredInput, 0 + 4));
		Set_Bit(input, 1, Get_Bit(registeredInput, 1 + 4));
		Set_Bit(input, 2, Get_Bit(registeredInput, 2 + 4));
		Set_Bit(input, 3, Get_Bit(registeredInput, 3 + 4));
		_input->Write8(0x20);
	}
	Write8(P1, input);
}

void MMU::DMATransfer()
{
	uint16 dma = Read8(DMA); //base address
	dma <<= 8;

	for (int dmaIndex = 0; dmaIndex < 0xA0; dmaIndex++)
	{
		//PUSH_AF();
		//_registers.A = Read8(0x0000); //Base address
		//Write8(DMA, _registers.A);
		//_registers.A = 0x28;
		//Sleep(160);
		//POP_AF();

		Write8(0xFE00 + dmaIndex, Read8(dma + dmaIndex));
	}
}